---
layout:         post
title:          网络相关
subtitle:       网络相关
date:           2018-07-05 08:08:00
author:         nomadli
header-img:     ../img/bg-coffee.jpeg
catalog:        true
tags:
        - other
---

# 减少用户态与内核态的内存拷贝
- read换mmap,读文件共享内核内存

```
风险:当mmap多进程/线程使用时,后续操作可能因其他进程/线程修改mmap导致crash
处理:1.捕捉SIGBUS信号并直接返回,后续操作也被终止
    2.fcntl(fd, F_SETSIG, RT_SIGNAL_LEASE)
      fcntl(fd, F_SETLEASE, l_type) 设置文件中断信号,捕捉信号后终止后续操作
```
- sendfile 替换read/mmap+write的组合,直接内核操作

```
风险:1.mmap一样,最好设置RT_SIGNAL_LEASE信号,不要抛出SIGBUS信号
    2.非POXI标准,移植问题
```

- splice 直接DMA用户态传输
```C
#include <fcntl.h>
ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);
// fd_in    read文件句柄, 如果是不可以随机读文件off_in=NULL从当前偏移位置读入
// fd_out   write文件句柄,如果是不可以随机写文件off_out=NULL从当前偏移写入
// len      数据长度
// flags
//      SPLICE_F_NONBLOCK splice调用不阻塞,但read或write没有设置noblock不起作用
//      SPLICE_F_MORE     还有后期splice系统调用更多数据
//      SPLICE_F_MOVE     如果可以整页内存移动
//      SPLICE_F_GIFT     
// fd_in和fd_out中必须至少有一个是管道文件描述符。

//使用splice实现的回显服务器
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
int main(int argc, char **argv) {
    if (argc <= 2) {
        printf("usage: %s ip port\n", basename(argv[0]));
        return 1;
    }

    struct sockaddr_in address;
    bzero(&address, sizeof(address));
    address.sin_family = AF_INET;
    address.sin_port = htons(atoi(argv[2]));
    inet_pton(AF_INET, argv[1], &address.sin_addr);
    int ssock = socket(PF_INET, SOCK_STREAM, 0);
    int reuse = 1;
    setsockopt(ssock, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));
    int ret = bind(ssock, (struct sockaddr*)&address, sizeof(address));
    ret = listen(ssock, 5);
    struct sockaddr_in client;
    socklen_t client_addrlength = sizeof(client);
    int csock = accept(ssock, (struct sockaddr*)&client, &client_addrlength);
    if (csock < 0) {
        printf("errno is: %s\n", strerror(errno));
    } else {
        int p2[2];  
        ret = pipe(p2);
        ret = splice(csock, NULL, p2[1], NULL, 32768, SPLICE_F_MORE|SPLICE_F_MOVE); 
        ret = splice(p2[0], NULL, csock, NULL, 32768, SPLICE_F_MORE| SPLICE_F_MOVE);
        close(p2);
    }
    close(csock);
    return 0;
}
```
- tee() 在两个管道间0拷贝传输数据,并且不消费数据,即调用后两个管道都能读到相同数据

# nginx
- ip 别名解决反向代理端口耗尽问题
```
ifconfig eth0:0 192.168.1.223 broadcast 192.168.1.255 netmask 255.255.255.0 up
route add -host 192.168.1.223 dev eth0:0
nginx中使用 split_clients proxy_bind
```

# ECMP 等价多路径路由
# Linux Virtual Server(director服务)
# [glb-director](https://github.com/github/glb-director)