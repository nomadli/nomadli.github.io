---
layout:         post
title:          C\C++ 11
subtitle:       C\C++11 特性
date:           2016-01-04 11:36:00
author:         nomadli
header-img:     ../img/bg-coffee.jpeg
catalog:        true
tags:
        - other
---

* content
{:toc}

# C++ 11
1. auto
    
        使用计算的实际类型，忽略顶层的const
        auto 函数名()->返回类型

2. decltype

        不计算只推断类型，变量与表达式结果不同
        自动生成返回类型

3. 语法特点
    
        % 取被余数的符号，商向0靠
        {} 初始化不允许丢失精度,可用于return
        位运算 对符号位没定义，移位超出或负数未定义
        sizeof运算符不求值、可以使用类作用域来访问属性
        for(declaration:expression)
        容器不可以在循环中增删，因为预存了end
        using name=type 等价 typedef
        不同作用域不会重载函数,引用、指针有const修饰也是重载

# C 98
01. register 编译优化时尽量将变量保存在寄存器中
02. volatile 变量会被其它线程修改,每次使用读取内存

# C 99
01. inline
02. restrict 修饰指针 表示此指针是这块内存地址的唯一指针

        int add(int *restrict a, int *restrict b) {
            *a = 5;
            *b = 6;
            return *a + *b;这里不用担心a与b指向相同的内存,因此汇编时不需要判断a指向的值变成6.
        }
    
3.  _Bool <stdbool.h> 是数字不能用true false
4. _Complex <complex.h> 复数
5. _Imaginary 虚数

# C 11
01. <stdalign.h> alignof aligned_alloc
02. _Noreturn void fxxx(xxx) 无法返回
03. _Generic 泛型函数

        void* func_int(int x){....}
        void* func_float(float x){....}
        void* func_char(char x){....}
        void* func_str(char *x){....}
        #defined func_all(x) _Generic((x), int:func_int, float:func_float, char:func_char, char*:func_str, default:func_int)(x);
        也可以是变量
        int a, c = 0;
        _Generic(x, int:a, float:c, default:a)++
        
04. <threads.h> 语言线程支持
    
        _Thread_local thrd_create thrd_exit
        mtx_lock mtx_unlock
    
05. <stdatomic.h> _Atomic
06. <uchar.h> Unicode 支持
07. quick_exit() exit()失败后,可以强制结束
08. CMPLX() 复数宏
09. <time.h> struct timespec 纳秒支持
10. _Alignas 在定义前 指定字节对齐

            _Alignas(4) int x;
            _Alignas(8) struct name {....}
            
11. _Alignof 获取变量 类型的对齐方式
12. _Atomic 原子变量 atomic_store 等
13. _Static_assert 编译起的assert

## 工具
01. objdump
02. otool(mac)
03. codesign(mac)
04. lipo(mac)
05. nm
    参数
    -A 每行或者显示全路径名称或者显示对象库名。
    -B 在 Berkeley 软件分发（BSD）格式中显示输出：值   类型   名称
    -C 限制解码（demangle） C++ 名称。缺省是解码所有 C++ 符号名。
    C++ 对象文件中的符号在被使用前它们的名称已经被解码了。
    -d 用十进制显示符号的值和大小。这是缺省的。
    -e 只显示静态的和外部的（全局）符号。
    -f 显示完整的输出，包括冗余的 .text、 .data 以及 .bss 符号，这些在常都是被限制的。
    -g 只显示外部的（全局）符号。
    -h 限制输出头数据的显示。
    -l 通过给 WEAK 符号的编码键附加一个 * 来区分 WEAK 和 GLOBAL 符号。如果和 -P 选项一起使用， WEAK 符号的符号类型显示如下：
            V Weak Data 符号
            W Weak Text 符号
            w Weak 未定义符号
            Z Weak bss 符号
    -o 用八进制而不是十进制数来显示符号的值和大小。
    -P 以标准可移植输出格式显示信息： 库／对象名　 名称   类型   值   大小
    该格式以十六进制符号表示法显示数字值，除非您用 -t、-d 或 -o 标志指定同的格式。 如果您指定了 -A 标志 -P 标志只显示 库／对象名字段。同样-P 标志只显示大小适用的符号大小字段。
    -p	不排序。输出按符号表顺序打印。
    -r	倒序排序。
    -T	把可能会溢出它的列的每个名字截短，使显示的名字的最后一个字符星号（*）。 缺省情况下，nm 显示列出的符号的全名，并且一个比为其设置的的宽度长的名称会引起名称后的每个列无法对齐。
    -t Format	显示指定格式下的数字值，其中 Format 参数是以下符号示法之一：
            d 十进制符号表示法。这是 nm 命令的缺省格式。
            o 八进制符号表示法。
            x 十六进制符号表示法。
    -u	只显示未定义符号。
    -v	按值而不是按字母表顺序排序输出。
    -x	用十六进制而不是十进制数来显示符号的值和大小。
    -X mode	指定 nm 应该检查的对象文件的类型。 mode 必须是下列之一：
            32 只处理 32 位对象文件
            64 只处理 64 位对象文件
            32_64 处理 32 位和 64 位对象文件
            缺省是处理 32 位对象文件（忽略 64 位对象）。 mode 也可以 OBJECT_MODE 环境变量来设置。例如，OBJECT_MODE=64 使 nm 处理任何 64 位对象并且忽略 32 位对象。 -X 标志覆盖 OBJECT_MODE 变量。
            
    符号标识 大小全局 小写局部
    - A 该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量中的位置。
    - B 该符号的值出现在非初始化数据段(bss)中。例如，在一个文件中定义全static int test。则该符号test的类型为b，位于bss section中。其值表该符号在bss段中的偏移。一般而言，bss段分配于RAM中
    - C 该符号为common。common symbol是未初始话数据段。该符号没有包含一个普通section中。只有在链接过程中才进行分配。符号的值表示该符号需要字节数。例如在一个c文件中，定义int test，并且该符号在别的地方会被引用则该符号类型即为C。否则其类型为B。
    - D 该符号位于初始话数据段中。一般来说，分配到data section中。例如定全局int baud_table[5] = {9600, 19200, 38400, 57600, 115200}则会分配于初始化数据段中。
    G 该符号也位于初始化数据段中。主要用于small object提高访问smalldata object的一种方式。
    - I 该符号是对另一个符号的间接引用。
    - N 该符号是一个debugging符号。
    - R 该符号位于只读数据区。例如定义全局const int test[] = {123,123};则test就是一个只读数据区的符号。注意在cygwin下如果使用gcc直接译成MZ格式时，源文件中的test对应_test，并且其符号类型为D，即初始化数段中。但是如果使用m6812-elf-gcc这样的交叉编译工具，源文件中的test对目标文件的test,即没有添加下划线，并且其符号类型为R。一般而言，位rodata section。值得注意的是，如果在一个函数中定义const char *test= “abc”, const char test_int = 3。使用nm都不会得到符号信息，但是符串“abc”分配于只读存储器中，test在rodata section中，大小为4。
    - S 符号位于非初始化数据区，用于small object。
    - T 该符号位于代码区text section。
    - U 该符号在当前文件中是未定义的，即该符号的定义在别的文件中。例如，当文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符类型为C，在使用它的文件中，其类型为U。
    - V 该符号是一个weak object。
    - W The symbol is a weak symbol that has not beenspecifically tagged as a weak object symbol.
    - 该符号是a.out格式文件中的stabs symbol。
        - ? 该符号类型没有定义

06. objcopy --redefine-sym xx.a=yy.a

## 头文件搜索
1. C_INCLUDE_PATH   xx:xx
2. CPLUS_INCLUDE_PATH xx:xx
3. OBJC_INCLUDE_PATH xx:xx
4. -nostdinc 不搜索系统路径及上诉变量指定的路径
5. PKG_CONFIG_PATH

## 库搜索优先级
1. 编译目标代码时指定的动态库搜索路径
2. 环境变量LD_LIBRARY_PATH指定的动态库搜索路径
3. 配置文件/etc/ld.so.conf中指定的动态库搜索路径
4. /lib
5. /usr/lib
6. PKG_CONFIG_PATH

## 库管理工具
- [vcpkg](https://github.com/Microsoft/vcpkg)
    - 不支持版本控制
    - 使用git,cmake每个客户端自动编译
- [Conan](https://github.com/conan-io/conan)

## 编译参数
- \-static 后面的是静态链接库
- \–Bdynamic 后面是动态库
- \-Bstatic 后面是静态库
- \-Wl 后面的参数传递给链接器
- \-Wl,\-\-whole-archive 链接所有函数,不删除未使用的函数(包括三方静态库）
- \-Wl,\-\-no-whole-archive 恢复函数裁剪,删除不使用的函数

## gcc
- gcc -E 打印宏展开代码
- -FPIC 生成的动态库内存位置无关,即所有程序用同一个动态库内存版本,不加则每个程序将动态库加载进自己的内存空间。当动态库有大量的全局变量时最好是各自一份

## Conan
- Artifactory
    - [Artifactory](https://jfrog.com/zh/artifactory/)
    - [Artifactory source](https://api.bintray.com/content/jfrog/artifactory/jfrog-artifactory-oss-$latest-sources.tar.gz;bt_package=jfrog-artifactory-oss-zip)
    - [Artifactory crack](https://github.com/r4p3-iooi/artifactory-injector)
    - 强大支持各种不同的源版本存储管理服务器
- JFrog Bintray 包分布式分发系统
- conan_sever 自带的包管理,没有权限及UI
- [cmake-conan](https://github.com/conan-io/cmake-conan)
- [docker](https://github.com/conan-io/conan-docker-tools)
- [介绍](https://docs.conan.io) 
- conanfile.txt #conan install -s os="Linux" -s compiler="gcc"

```
include(default)
[settings]
os=Macos
arch=x86_64
compiler=clang
compiler.version=3.5
compiler.libcxx=libstdc++11
build_type=Release
[env]
CC=/usr/bin/clang
CXX=/usr/bin/clang++
[requires]
ssl/1.0.1@eastmoney/stable      #库/版本@存储商/版本类型
[generators]
cmake                           #编译方式,cmake需要有CMakeLists.txt、gcc
[options]
ssl:shared=True                 #选项
[imports]
bin,*.dll -> ./bin              #将动态库导入可执行文件的目录
```
