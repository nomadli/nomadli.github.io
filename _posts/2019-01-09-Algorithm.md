---
layout:         post
title:          算法
subtitle:       算法 笔记
date:           2019-01-09 09:18:00
author:         nomadli
header-img:     ../img/bg-coffee.jpeg
catalog:        true
tags:
        - other
---

* content
{:toc}

## 时间复杂度 大O表示法
- 时间复杂度指的是执行步骤的数量,而不是时间
- 表示算法耗时随数据增加的增速,重在趋势,因此常量一般忽略,当复杂度相同时才需要常量
- 表示最差情况下的步骤数,即不可能超过的步骤数
- $O(log(n))$ 表示 $O(log_2(n))$

## 二分查找
- $O(log(n))$
- 必须有序

## 选择排序
- $O(n^2)$
- 每趟在剩余的数据中选择一个放到排序好的数据后
- 平均运行步骤 $1/2n^2$

## 快速排序
- $O(n*log(n))$
- 分治的思想,分治一般会使用递归 D&C(divide and conquer)
- 使用尾递归减少深度或转换为循环
- 选择一个值将数据分为两部分,递归直到数据<=2个
- qsort使用快速排序

## 散列表数据结构
- $O(1)$
- 填装因子,当占用到百分比,好的hash一般在70%时需要扩容
- 数组+链表结构
- SHA是一个比较常用的散列函数

## 广度优先搜索
- $O(定点+边)$记做$O(V+E)
- 以图为基础、解决跳跃最少路径、是否可达问题
- 通过队列来实现,将一度可达压入队列,出队列的值做标记并继续一度压入
- 图一般以散列表做数据结构,即map的value是链表
- 有向图并单方向向下形成树结构

## 迪克斯特拉算法(Dijkstra's algorithm)
- 以加权有向无环图为基础(权值不能有负数)、解决最快路径
    - 出发点A,通过表记录A到所有节点的权值,不可直达权无穷大,并记录其父节点
    - 找出A一度权值最小节点B
    - 计算A经过B到达B邻居的权值,如果比记录小更新记录及父节点
    - 对B点从第二步开始重复做权值更新直到到达最终点的最小一度权值
    - 从终点的父节点开始倒推路径
- 负权边可使用贝尔曼-福德算法(Bellman-Ford algorithm)

## 贪婪算法
- 每步在可以选择的数据中找到最优解,即为最终解
- 结果可能不是最优解、但简单且接近最优
- 在集合覆盖问题上,计算需要得出所有的解(NP完全问题),但计算量以阶乘速率上升